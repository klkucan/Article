###OC
- oc由smalltalk演化而来，是消息结构语言，和函数调用语言不同。因此在语法上完全不一样。
-  在类的头文件中减少引用其它类的头文件，因为会增加编译时间、而且暴露一些没有必要暴露的类，可以使用@class来做向前声明。
-  多用字面量，少用与之相对的方法。原因是：1、写法简单明了，尤其是dictionary的写法比较符合习惯（是key-value，而对象的方法是value-key)。第二、字面量集合中如果有nil的对象会抛出异常并有编译器的提示。而方法的话如果有对象是nil不会报错，而且如果一个数组加入了nil，会使得nil后的对象丢失，因为创建时nil作为了结束符。
-  多用类型常量，少用#define。因为#define本质是字符串替换，所有有错误不能识别。而且如果被修改了也不会报错。
-  在状态、选项、状态码时使用枚举。无他，方便尔。而且NS_OPTION支持位运算。

###对象、消息、运行期
- 属性：
  - 默认带get/set方法，可以自己定义。
  - 默认产生一个_XXX的实例变量，可以通过@synthesize XXX = specialXXX来重命名这个实例变量。
  - 如果不写nonatomic默认就是原子性，所谓原子性是编译器在合成的get/set方法中加入锁，Mac OS系统编程没事，但是iOS系统上同步锁开销较大，这也是iOS编程基本都是nonatomic的原因。
  - 内存管理语义，assign、strong、weak、unsafe_unretained、copy。注意一点如果自己实现get/set方法需要对内存语义进行相关处理。比如一个属性是copy的，那么在方法中要实现这个。
  
- 在对象内部尽量直接访问实例变量。
  - 也就是说如果有属性XXX，那么在get值时尽量使用_XXX而不是self.XXX。因为后者本质是一个方法的调用。
  - 而在set的时候还是使用`self.XXX == YYY`的写法，因为直接访问实例变量会绕过属性的内存管理语义，比如属性是copy的，直接复制是不会copy的。因为本质上没有调用set方法，而这个方法是有copy的操作的。还有这样会绕过KVO。
  - 总之如果在get/set方法中有一些特别的操作的话还是调用`self.XXX`比较好。

- 对象等同性
  - 不要使用`==`，因为这个对比的是指针，而要使用`isEqual`方法。某些对象提供特殊的等同性判定方法，比如`isEqualToString`。
  - NSObject提供两个判定等同性的方法，isEqual和hash。默认实现是：当且仅当其“指针值”（内存地址）完全相等时，这两个对象才相等。<font color=red>对象相同hash未必相同</font> 
  - 如果把某个对象放入set之后又修改其内容，后面的行为将难以预料。
 
- 以类族模式隐藏细节：以UIButton为例，在UIButton类后面有很多子类，在创建不同类型的按钮时实际上是在创建子类对象。此时如果直接用==来比较类型`[xxx class] == [UIButton class]`结果为NO，需要使用`isKindOfClass`方法。

- 在既有类中使用关联对象存放自定义数据（我只想说这个功能好NB）

- objc_msgSend：
  - OC是动态语言，在执行函数的时候调用objc_msgSend，接受者对象开始在其类的方法列表中找寻方法，如果没有则按照继承体系向上找，如果最终都找不到则进行消息转发。 
  - objc_msgSend方法会将匹配的结果放到一个快速映射表中，下次在调用某个方法的时候会快很多。
  - PS:静态语言和动态语言。所谓静态是编译的时候直接生成调用这些函数的指令，函数地址是硬编码在指令中的。而动态，需要运行到这里时才确定使用什么函数。
 
- objc_msgSend的流程和转发流程
	1.   先看一个对象是否有指定的SEL，如果有执行。
	2.   如果没有，调用resolveInstanceMethod方法查看能不能新增一个实例方法来处理选择子。
	3.   如果没有新增方法，则调用forwardingTargetForSelector看有没有被援接受者。
	4.   如果没有被援接受者执行完整的消息转发forwardInvocation
   
- 转发流程的利用
- isa：应该念做“is a”,本质是一个指针。oc中每个实例对象中都有这个，就和C#的类型指针是一个概念，而且OC中也有“类类型”，只不过叫做类对象，类对象也有个isa指向metaclass，其中包含了方法内容。基本来说和C#是一样的。
![](images/isa.png) ![](images/class.png)                            
   
###类和协议
- 将一个类中的功能分为多个分类中，便于管理。
- 创建分类和分类的函数时使用一些前缀，这样主要是避免与其它人创建的分类函数出现同名，进而被覆盖。
- 分类中可以创建属性，但是不支持自动生成实例变量，而且自己写的话很麻烦，还要管理内容语义，因此不要在分类中写属性。
- 使用class-continuation来隐藏细节，这是一个特殊的分类，只有（）没有名称。里面可以定义属性、变量、方法。这些都是外部无法访问的。